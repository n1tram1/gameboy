!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/45968eff/
CPU	src/cpu.rs	/^impl CPU {$/;"	c
CPU	src/cpu.rs	/^pub struct CPU {$/;"	s
Cartridge	src/cartridge.rs	/^impl Cartridge {$/;"	c
Cartridge	src/cartridge.rs	/^pub struct Cartridge {$/;"	s
CartridgeInfo	src/cartridge_info.rs	/^impl CartridgeInfo {$/;"	c
CartridgeInfo	src/cartridge_info.rs	/^pub struct CartridgeInfo {$/;"	s
INSTRUCTIONS	src/instructions.rs	/^pub static INSTRUCTIONS: &'static [Instruction] = &[$/;"	v
Instruction	src/instructions.rs	/^pub struct Instruction {$/;"	s
MMU	src/mmu.rs	/^impl MMU {$/;"	c
MMU	src/mmu.rs	/^pub struct MMU {$/;"	s
af	src/cpu.rs	/^    af: u16,$/;"	m	struct:CPU
bc	src/cpu.rs	/^    bc: u16,$/;"	m	struct:CPU
cartridge	src/main.rs	/^mod cartridge;$/;"	n
cartridge	src/mmu.rs	/^    cartridge: Cartridge,$/;"	m	struct:MMU
cartridge_info	src/main.rs	/^mod cartridge_info;$/;"	n
cpu	src/main.rs	/^mod cpu;$/;"	n
cycle	src/cpu.rs	/^    pub fn cycle(&mut self) {$/;"	P	implementation:CPU
cycles	src/instructions.rs	/^    pub cycles: u8,$/;"	m	struct:Instruction
cycles_remaining	src/cpu.rs	/^    cycles_remaining: u8,$/;"	m	struct:CPU
de	src/cpu.rs	/^    de: u16,$/;"	m	struct:CPU
decode_opcode	src/cpu.rs	/^    fn decode_opcode(&self, opcode: u8) -> &Instruction {$/;"	P	implementation:CPU
extract_title	src/cartridge_info.rs	/^    fn extract_title(rom_data: &Vec<u8>) -> String {$/;"	P	implementation:CartridgeInfo
fetch_next_opcode	src/cpu.rs	/^    fn fetch_next_opcode(&self) -> u8 {$/;"	P	implementation:CPU
get_af	src/cpu.rs	/^    pub fn get_af(self) -> u16 { self.af }$/;"	P	implementation:CPU
get_bc	src/cpu.rs	/^    pub fn get_bc(self) -> u16 { self.bc }$/;"	P	implementation:CPU
get_de	src/cpu.rs	/^    pub fn get_de(self) -> u16 { self.de }$/;"	P	implementation:CPU
get_hl	src/cpu.rs	/^    pub fn get_hl(self) -> u16 { self.hl }$/;"	P	implementation:CPU
hl	src/cpu.rs	/^    hl: u16,$/;"	m	struct:CPU
info	src/cartridge.rs	/^    pub info: CartridgeInfo,$/;"	m	struct:Cartridge
instruction	src/cpu.rs	/^    instruction: u32,$/;"	m	struct:CPU
instructions	src/main.rs	/^mod instructions;$/;"	n
length	src/instructions.rs	/^    pub length: u16,$/;"	m	struct:Instruction
main	src/main.rs	/^fn main() {$/;"	f
mmu	src/cpu.rs	/^    mmu: MMU,$/;"	m	struct:CPU
mmu	src/main.rs	/^mod mmu;$/;"	n
name	src/instructions.rs	/^    pub name: &'static str,$/;"	m	struct:Instruction
new	src/cartridge.rs	/^    pub fn new(rom_path: &path::Path) -> Cartridge {$/;"	P	implementation:Cartridge
new	src/cartridge_info.rs	/^    pub fn new(rom_data: &Vec<u8>) -> CartridgeInfo {$/;"	P	implementation:CartridgeInfo
new	src/cpu.rs	/^    pub fn new (path: &path::Path) -> CPU {$/;"	P	implementation:CPU
new	src/mmu.rs	/^    pub fn new(path: &path::Path) -> MMU {$/;"	P	implementation:MMU
pc	src/cpu.rs	/^    pc: u16,$/;"	m	struct:CPU
print_regs	src/cpu.rs	/^    fn print_regs(&self) {$/;"	P	implementation:CPU
read	src/cartridge.rs	/^    pub fn read(&self, addr: u16) -> u8 {$/;"	P	implementation:Cartridge
read	src/mmu.rs	/^    pub fn read(&self, addr: u16) -> u8 {$/;"	P	implementation:MMU
rom_data	src/cartridge.rs	/^    rom_data: Vec<u8>,$/;"	m	struct:Cartridge
set_af	src/cpu.rs	/^    pub fn set_af(mut self, val: u16) { self.af = val }$/;"	P	implementation:CPU
set_bc	src/cpu.rs	/^    pub fn set_bc(mut self, val: u16) { self.bc = val }$/;"	P	implementation:CPU
set_de	src/cpu.rs	/^    pub fn set_de(mut self, val: u16) { self.de = val }$/;"	P	implementation:CPU
set_hl	src/cpu.rs	/^    pub fn set_hl(mut self, val: u16) { self.hl = val }$/;"	P	implementation:CPU
sp	src/cpu.rs	/^    sp: u16,$/;"	m	struct:CPU
title	src/cartridge_info.rs	/^    pub title: String,$/;"	m	struct:CartridgeInfo
total_cycles	src/cpu.rs	/^    total_cycles: usize,$/;"	m	struct:CPU
